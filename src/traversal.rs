use ::Nav;
use std::collections::VecDeque;
use std::marker::PhantomData;

/// Persistent queue that imposes an ordering on data.
///
/// This trait is characterized by the ordering it imposes on a stream of
/// data. Based on the semantics of `shift` and `unshift`, which consume a
/// stream of data items one at a time, 
///
/// This is used in tree traversals to determine the order in which tree nodes
/// are visited:
///
/// * Depth-first traversal is done when `shift` and `unshift` have push/pop
/// (last in, first out) semantics, so that unshifting each child of a tree node
/// and recurring results in a traversal in which the first grandchild is
/// visited prior to the last child.
/// * Breadth-first traversal is done when `shift` and `unshift` have
/// enqueue/dequeue semantics (first in, first out), so that unshifting each
/// child of a tree node and recurring results in a traversal in which the last
/// child is visited before the first grandchild.
/// * Other traversal orders can be generated by more exotic queue
/// implementations.
pub trait Queue<T> {
    /// Returns the number of elements in the queue.
    fn len(&self) -> usize;

    /// Returns `true` iff the queue has no elements.
    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Peeks at the next item to be returned by `shift.
    ///
    /// Returns `None` if the queue is empty.
    fn first(&self) -> Option<&T>;

    /// Adds an item to the queue.
    fn unshift(&mut self, t: T);

    /// Pulls the next available item from the queue.
    ///
    /// Returns `None` if the queue is empty.
    fn shift(&mut self) -> Option<T>;
}

/// `std::Vec`-backed queue with last in, first out ordering. Used for
/// depth-first search.
///
/// Note that the search which this queue powers visits a node's immediate
/// children in reverse order.
pub struct DepthQueue<T> {
    v: Vec<T>,
}

impl<T> DepthQueue<T> {
    pub fn new() -> Self { DepthQueue { v: Vec::new(), } }
}

impl<T> Queue<T> for DepthQueue<T> {
    fn len(&self) -> usize { self.v.len() }
    fn first(&self) -> Option<&T> { self.v.first() }
    fn unshift(&mut self, t: T) { self.v.push(t); }
    fn shift(&mut self) -> Option<T> { self.v.pop() }
}

/// `std::collections::VecDeque`-backed queue with first in, first out
/// ordering. Used for breadth-first search.
pub struct BreadthQueue<T> {
    v: VecDeque<T>,
}

impl<T> BreadthQueue<T> {
    pub fn new() -> Self { BreadthQueue { v: VecDeque::new(), } }
}

impl<T> Queue<T> for BreadthQueue<T> {
    fn len(&self) -> usize { self.v.len() }
    fn first(&self) -> Option<&T> { self.v.front() }
    fn unshift(&mut self, t: T) { self.v.push_back(t) }
    fn shift(&mut self) -> Option<T> { self.v.pop_front() }
}

/// Traverses a tree with a visitor function that is called at each node.
///
/// The traversal starts at the tree location `n` and proceeds through it and
/// all nodes below it in the order defined by `queue`. At each node,
/// `predicate` is called with a pointer to the current tree node.
pub fn traverse<'a, N, Q, F>(n: N, mut queue: Q, predicate: F)
    where N: Nav<'a> + Clone, Q: Queue<N>, F: Fn(N) {
        queue.unshift(n);
        loop {
            match queue.shift() {
                None => return,
                Some(next) => {
                    predicate(next.clone());
                    if ! next.at_leaf() {
                        for i in 0..next.child_count() {
                            let mut child = next.clone();
                            child.seek_child(i);
                            queue.unshift(child);
                        }
                    }
                }
            }
        }
    }

/// Finds the first node in a tree matching a predicate.
///
/// The search starts at the tree location `n` and proceeds through it and all
/// nodes below it in the order defined by `queue`. At each node, `predicate` is
/// called with a pointer to the current tree node. If `predicate` returns
/// `true`, a pointer to the current tree location is returned. If `predicate`
/// never returns `true`, `None` is returned.
pub fn find_first<'a, N, Q, F>(n: N, mut queue: Q, predicate: F) -> Option<N>
    where N: Nav<'a> + Clone, Q: Queue<N>, F: Fn(N) -> bool {
        queue.unshift(n);
        loop {
            match queue.shift() {
                None => return None,
                Some(next) => {
                    if predicate(next.clone()) {
                        return Some(next);
                    }
                    if ! next.at_leaf() {
                        for i in 0..next.child_count() {
                            let mut child = next.clone();
                            child.seek_child(i);
                            queue.unshift(child);
                        }
                    }
                },
            }
        }
    }

/// Iterator closing over a tree search environment.
pub struct FindIter<'a, N: 'a, Q, F>
    where N: Nav<'a> + Clone, Q: Queue<N>, F: Fn(N) -> bool {
        phantom: PhantomData<&'a N>,
        predicate: F,
        queue: Q,
    }

impl<'a, N: 'a, Q, F> Iterator for FindIter<'a, N, Q, F>
    where N: Nav<'a> + Clone, Q: Queue<N>, F: Fn(N) -> bool {
        type Item = N;
        fn next(&mut self) -> Option<N> {
            loop {
                match self.queue.shift() {
                    None => return None,
                    Some(next) => {
                        if ! next.at_leaf() {
                            for i in 0..next.child_count() {
                                let mut child = next.clone();
                                child.seek_child(i);
                                self.queue.unshift(child);
                            }
                        }
                        let f = &self.predicate;
                        if f(next.clone()) {
                            return Some(next);
                        }
                    },
                }
            }
        }
    }

/// Finds all nodes in a tree matching a predicate.
///
/// The search starts at the tree location `n` and proceeds through it and all
/// nodes below it in the order defined by `queue`. At each node, `predicate` is
/// called with a pointer to the current tree node. The iterator yields only
/// nodes for which `predicate` returned `true`.
pub fn find_all<'a, N, Q, F>(n: N, mut queue: Q, predicate: F) -> FindIter<'a, N, Q, F>
    where N: Nav<'a> + Clone, Q: Queue<N>, F: Fn(N) -> bool {
        queue.unshift(n);
        FindIter { phantom: PhantomData, predicate: predicate, queue: queue, }
    }
